<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>Fire Analyzer</title>

  <style>
    body {
      font-family: Arial, sans-serif;
    }
    .container {
      display: flex;
      gap: 12px;
      margin-top: 10px;
    }
    .panel {
      text-align: center;
    }
    canvas {
      border: 1px solid #ccc;
      display: block;
    }
    .result {
      margin-top: 6px;
      font-size: 14px;
    }
    #summary {
      margin-top: 20px;
      font-size: 18px;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h2>Fire / Forest Analyzer</h2>
<button id="connectBtn">Connect Camera</button>

<br><br>

<video id="remoteVideo" muted playsinline style="display:none;"></video>

<div class="container">
  <div class="panel">
    <canvas id="leftCanvas" width="160" height="120"></canvas>
    <div class="result" id="leftResult">-</div>
  </div>
  <div class="panel">
    <canvas id="centerCanvas" width="160" height="120"></canvas>
    <div class="result" id="centerResult">-</div>
  </div>
  <div class="panel">
    <canvas id="rightCanvas" width="160" height="120"></canvas>
    <div class="result" id="rightResult">-</div>
  </div>
</div>

<div id="summary">Waiting...</div>

<!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

<!-- Teachable Machine -->
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>

<!-- PeerJS -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>


<script>
  const video = document.getElementById('remoteVideo');
  const connectBtn = document.getElementById('connectBtn');

  const peer = new Peer();
  let model = null;
  let timer = null;

  /* ===============================
     더미 video track 생성 (핵심)
  =============================== */
  async function createDummyStream() {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, 1, 1);
    return canvas.captureStream(1);
  }

  /* ===============================
     카메라 연결
  =============================== */
  connectBtn.onclick = async () => {
    const dummyStream = await createDummyStream();
    const call = peer.call('camera-sender', dummyStream);

    if (!call) {
      console.error('Call failed');
      return;
    }

    call.on('stream', stream => {
      console.log('Analyzer received stream');

      video.srcObject = stream;

      video.onloadedmetadata = async () => {
        await video.play();
        await loadModel();

        if (timer) clearInterval(timer);
        timer = setInterval(analyzeFrame, 500);
      };
    });
  };

  /* ===============================
     Teachable Machine 로드
  =============================== */
  async function loadModel() {
    const modelURL =
      'https://teachablemachine.withgoogle.com/models/XXXXX/model.json';
    const metadataURL =
      'https://teachablemachine.withgoogle.com/models/XXXXX/metadata.json';

    model = await tmImage.load(modelURL, metadataURL);
    console.log('Model loaded');
  }

  /* ===============================
     Canvas 설정
  =============================== */
  const leftCanvas = document.getElementById('leftCanvas');
  const centerCanvas = document.getElementById('centerCanvas');
  const rightCanvas = document.getElementById('rightCanvas');

  const lctx = leftCanvas.getContext('2d');
  const cctx = centerCanvas.getContext('2d');
  const rctx = rightCanvas.getContext('2d');

  /* ===============================
     프레임 분석
  =============================== */
  async function analyzeFrame() {
    if (!model) return;

    const vw = video.videoWidth;
    const vh = video.videoHeight;
    if (!vw || !vh) return;

    const part = vw / 3;

    lctx.drawImage(video, 0, 0, part, vh, 0, 0, 160, 120);
    cctx.drawImage(video, part, 0, part, vh, 0, 0, 160, 120);
    rctx.drawImage(video, part * 2, 0, part, vh, 0, 0, 160, 120);

    const L = await model.predict(leftCanvas);
    const C = await model.predict(centerCanvas);
    const R = await model.predict(rightCanvas);

    updateUI(L, C, R);
  }

  /* ===============================
     결과 처리
  =============================== */
  function getScores(pred) {
    const fire = pred.find(p => p.className === 'fire').probability;
    const forest = pred.find(p => p.className === 'forest').probability;
    return { fire, forest };
  }

  function updateUI(l, c, r) {
    const L = getScores(l);
    const C = getScores(c);
    const R = getScores(r);

    leftResult.textContent =
      `Fire ${(L.fire * 100).toFixed(1)}% / Forest ${(L.forest * 100).toFixed(1)}%`;
    centerResult.textContent =
      `Fire ${(C.fire * 100).toFixed(1)}% / Forest ${(C.forest * 100).toFixed(1)}%`;
    rightResult.textContent =
      `Fire ${(R.fire * 100).toFixed(1)}% / Forest ${(R.forest * 100).toFixed(1)}%`;

    const safest = [
      { name: 'LEFT', score: L.forest },
      { name: 'CENTER', score: C.forest },
      { name: 'RIGHT', score: R.forest }
    ].sort((a, b) => b.score - a.score)[0];

    summary.textContent = `Safest area: ${safest.name}`;
  }
</script>

</body>
</html>

